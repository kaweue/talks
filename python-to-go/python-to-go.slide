Przejdźmy na GO! - studium przypadku

Paweł Marchewka
Katarzyna Rybacka
Codilime

* Tungsten Fabric

* Tungsten Fabric

SDN (Software Defined Networks) - wirtualne sieci dla wirtualnych komputerów

.image python-to-go/img/one-rule.png _ 480

* Architektura
Dość rozbudowana

.image python-to-go/img/contrail_simple.png _ 600

* Problemy

* Język - Python:

- Dynamiczne typowanie
- Brak wsparcia dla współbieżności
- Brak ustandaryzowanego stylu kodowania
- Brak organizacji kodu

* Dynamiczne typowanie
Argumentem większości metod tajemniczy *obj_dict*
*Efekt*:

- Brak kontroli nad przyjmowanymi argumentami
- Niezrozumiały kod
- Programista zakłada z czym ma do czynienia

    def pre_dbe_create(cls, tenant_name, obj_dict, db_conn):
    ...
    ...
        try:
            if (obj_dict['parent_type'] != 'virtual-network' or
                obj_dict['floating_ip_pool_subnets'] is None or
                obj_dict['floating_ip_pool_subnets']['subnet_uuid'] is None or
                    not obj_dict['floating_ip_pool_subnets']['subnet_uuid']):
                return True, ""
        except (KeyError, TypeError):
            return True, ""

* A żeby zrozumieć tę metodę..

    def pre_dbe_create(cls, tenant_name, obj_dict, db_conn):
        #
        # Floating-ip-pools corresponding to a virtual-network can be
        # 'optionally' configured to be specific to a ipam subnet on a virtual-
        # network.
        #
        # If the subnet is specified, sanity check the config to verify that
        # the subnet exists in the virtual-network.
        #

        # If subnet info is not specified in the floating-ip-pool object, then
        # there is nothing to validate. Just return.
        try:
            if (obj_dict['parent_type'] != 'virtual-network' or
                obj_dict['floating_ip_pool_subnets'] is None or
                obj_dict['floating_ip_pool_subnets']['subnet_uuid'] is None or
                    not obj_dict['floating_ip_pool_subnets']['subnet_uuid']):
                return True, ""
        except (KeyError, TypeError):
            return True, ""

* Brak ustandaryzowanego stylu kodowania
W obrębie jednej metody:

    if 'segmentation_id' not in properties:
        return (False, "Segmenation id must be configured")

    if not properties.get('physical_network'):
        return (False, "physical network must be configured")

Można spotkać też dość nietypowe konwencje:
.image python-to-go/img/reutrn.png _ 900

* Brak organizacji kodu
.image python-to-go/img/server_line.png

* A z innej beczki..
Jedyną wspieraną wersją jest *Python2.7.13*

* Problem
To próba wykorzystania pliku po jego zamknięciu.
Znaleziono na to powszechnie wykorzystywane rozwiązanie:

    sed -i 's/self.close()/#self.close()/g' /usr/lib64/python2.7/xml/sax/xmlreader.py

* Brak transakcji

- Dwie bazy danych: Cassandra, Zookeeper
- Sztuczny rollback za pomocą metod *undo..()*
.image python-to-go/img/undo.png 460 _

* Nierozwijalny system

Obecna architektura oraz stan kodu nie pozwala na dodanie nowych, istotnych funkcji
.image python-to-go/img/contrail_simple.png _ 600

* Napiszmy wszystko od nowa

* Założenia

Przejdźmy na GO

Zmieńmy architekturę

*5* komponentów - *147374* lini kodu

*5* miesięcy - *10* programistów

* Czemu GO?

- Statycznie typowany

- Prosty do nauki:
_“Do_Less._Enable_More.“_

- Posiada rozbudowane narzędzia statycznej analizy kodu:
_“Gofmt's_style_is_no_one's_favorite,_yet_gofmt_is_everyone's_favorite”_

- Szybki kompilator:
_“Go_was_developed_while_waiting_for_a_C++_program_to_compile”_

- Generyczne wsparcie współbieżności

* Co może pójść nie tak?

* Niejedno, wiele, dużo

* Errors are values

* Error

W Go error to interfejs

    type error interface {
        Error() string
    }

Najprostrza implementacja

    type errorString struct {
        s string
    }

    func (e *errorString) Error() string {
        return e.s
    }

* Obsługa błędów gorzej

.play -edit errors_bad.go /START OMIT/,/END OMIT/

* Obsługa błędów lepiej
.play errors_good.go /START OMIT/,/END OMIT/

* Make the zero value useful (or useless?)

* Problem

W JSONie pole może mieć 3 stany:

- posiada wartość
- jest puste
- pole nie występuje

W Pythonie dość łatwo można to wyrazić

    if 'ipam_subnet_method' in obj_dict:
        new_subnet_method = obj_dict.get('ipam_subnet_method')
        if (old_subnet_method != new_subnet_method):
            return (False, (400, 'ipam_subnet_method can not be changed'))

* Make the zero value useful

.play -edit json.go /START OMIT/,/END OMIT/

* Pointers

.play -edit json_pointer.go /START OMIT/,/END OMIT/

* Fieldmask

Python

    if 'ipam_subnet_method' in obj_dict:
        new_subnet_method = obj_dict.get('ipam_subnet_method')
        if (old_subnet_method != new_subnet_method):
            return (False, (400, 'ipam_subnet_method can not be changed'))

Go

	if format.CheckPath(fieldMask, []string{models.NetworkIpamFieldIpamSubnetMethod}) {
		if oldIpam.GetIpamSubnetMethod() != newIpam.GetIpamSubnetMethod() {
			return errors.Errorf("Subnet method cannot be changed")
		}
	}
	return nil

* Go = brak generyczności

* Jak możemy sobie z tym poradzić?

* Interfejsy
.code interface.go /START OMIT/,/END OMIT/

* Jakie korzyści?

- Zyskaliśmy pewną elastyczność.
- Podejście czyste i idiomatyczne

Ale:

- Możemy korzystać tylko z metod interfejsu, nie typu
- Redundantne metody dla typów spełniających interfejs

* Gener..acja kodu
Skoro nie możemy stworzyć metody, która obsłuży wybrane przez nas typy ->
Stwórzmy tyle wersji metod ile typów chcemy obsłużyć

W tym celu wykorzystaliśmy szablony *Pongo2*:

.code generics.go /START OMIT/,/END OMIT/

* Zysk z generacji
- Statyczna kontrola typów w czasie kompilacji

- Unikanie użycia interface{} i asercji typów
_"interface{}_says_nothing."_

- Logika napisana raz

Kosztem:

- Plików o znacznej wielkości
- Potrzebą zewnętrznych narzędzi
